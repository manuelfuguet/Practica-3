

# Librerías necesarias
library(dplyr)
library(xtable)

# Definir la ruta del archivo ZIP y la de extracción
zip_file_path <- "C:/Users/andre/Downloads/epa-http.zip"
extract_to <- "C:/Users/andre/Downloads/extracted_files/"

# Crear el directorio de extracción si no existe
if (!dir.exists(extract_to)) {
  dir.create(extract_to)
}

# Descomprimir el archivo ZIP
unzip(zip_file_path, exdir = extract_to)

# Verifica que los archivos se han descomprimido correctamente
dir(extract_to)

# Definir la ruta del archivo extraído
extracted_file_path <- "C:/Users/andre/Downloads/extracted_files/epa-http.csv"

# Cargar los datos en un DataFrame
logs_df <- read.csv(extracted_file_path, header = TRUE, sep = " ")

# Cambiar los nombres de las columnas
colnames(logs_df) <- c("IP", "Timestamp", "Request Type", "URL", "Protocol", "Response Code", "Bytes of Reply")

# Verifica los nuevos nombres de las columnas
print(colnames(logs_df))


# Asegurarse de que los datos se carguen correctamente en columnas
head(logs_df)

# Convertir columnas al tipo adecuado
logs_df$IP <- as.numeric(logs_df$IP)
logs_df$Timestamp <- as.character(logs_df$Timestamp)
logs_df$Request Type <- as.factor(logs_df$Request Type)
logs_df$URL <- as.POSIXct(logs_df$URL, format="%Y-%m-%d %H:%M:%S")

# Eliminar espacios y caracteres innecesarios
logs_df$columna_texto <- trimws(logs_df$columna_texto)
logs_df$columna_texto <- gsub("[^[:alnum:] ]", "", logs_df$columna_texto)

# Manejo de valores faltantes
logs_df <- na.omit(logs_df)
logs_df$columna_numerica[is.na(logs_df$columna_numerica)] <- mean(logs_df$columna_numerica, na.rm = TRUE)

# Verificar la limpieza de los datos
print(summary(logs_df))

# Guardar el DataFrame limpio
write.csv(logs_df, "C:/Users/andre/Downloads/extracted_files/logs_df_limpio.csv", row.names = FALSE)

# Convertir a HTML y guardar
html_table <- xtable(logs_df)
print(html_table, type = "html", file = "C:/Users/andre/Downloads/extracted_files/logs_df.html")


